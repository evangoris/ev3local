"""Interface to events form an Xbox controller

Evan Goris
2015
"""

import os

from evdev import InputDevice, list_devices


def printevent(event):
    import evdev.ecodes
    print event.code, event.type, event.value
    print evdev.ecodes.bytype[event.type][event.code]
        
class XCEvents(object):
    """Manages a sequence of events from an Xbox controller

    Objects of this class poll for events from /dev/input
    An Xbox controller can be made a device under /dev/input with
    the userspace driver `xboxdrv`.    
    
    Responsibilities:
        Delivering Xbox events, non-blocking to interested parties.
        
    Implementation:
        Resource management: Thread that polls the controller
        
    """
    def __init__(self, callbacks=None):

        # The xbox device
        #
        self._xbox = self._finddevice()

        # List of callbacks that will be called
        # when xbox events occur
        #
        self._callbacks = callbacks or []

        # The thread that polls the controller
        # Will be initialized in __enter__()
        #
        self._t = None

    def add_callback(self, callback):
        self._callbacks.append(callback)

    def remove_callback(self, callback):
        self._callbacks.remove(callback)

    def connectaxes(self, callback, axes, max=1.0, min=-1.0):
        import evdev, evdev.ecodes

        if type(axes)==str:
            eventcode = evdev.ecodes.ecodes[axes]
        else:
            eventcode = axes

        absinfo = self.absinfo(eventcode)
        axesmin = float(absinfo.min)
        axesmax = float(absinfo.max)

        def callback1(event):
            if event.type==evdev.ecodes.ecodes['EV_ABS'] and event.code==evdev.ecodes.ecodes[axes]:
                value = float(event.value)
                if value>0:
                    value = (value/axesmax)*max
                else:
                    value = (value/axesmin)*min
                callback(value)

        self.add_callback(callback1)
        return callback1

    def absinfo(self, type_):
        """Get information on an absolute input axis
        
        Args:
            type_ (int or str): Code or symbolic name of an absolute axis
            
        Returns:
            AbsInfo: Named tuple with info on `type_`
        """
        import evdev.ecodes
        cap = self._xbox.capabilities(absinfo=True, verbose=False)
        if type(type_)==str:
            typecode = evdev.ecodes.ecodes[type_]
        else:
            typecode = type_
        abscode = evdev.ecodes.ecodes['EV_ABS']
        for info in cap[abscode]:
            if info[0]==typecode:
                return info[1]
            
    
    def _finddevice(self):
        """Search for the device that represents the xbox controller
        
        Returns:
            InputDevice: The xbox controller
            
        Raises:
            IOError: When no controller can be found
        """
        devices = [ InputDevice(fn) for fn in list_devices() ]
        for dev in devices:
            if dev.name.startswith('Xbox Gamepad'):
                return dev
        
        raise IOError("No Xbox controller found")
    
    def __enter__(self):
        self._init()
        return self

    def __exit__(self, type_, value, traceback):
        self.stop()

    def _init(self):
        # Initialize signalling file descriptors to break
        # the endless select loop. If anything is written
        # over this pipe then the event sequence generated
        # by self.eventsequence() will end.
        #
        self.__signalrfd, self.__signalwfd = os.pipe()

        # Start up a thread that waits for events from
        # the controller.
        #
        import threading
        self._t = threading.Thread(target=self._processevents,args=())
        self._t.deamon = True

    def start(self):
        """Fire up a thread that polls the controller
        """
        if not self._t:
            self._init()
        self._t.start()

    def stop(self):
        """Stop the thread that polls the controller and release resources
        """
        if not self.__signalwfd:

            if self._t:
                raise RuntimeWarning("XCEvents inproperty shut down")

            # Stopped already
            #
            return

        # Signal the event sequence to end and thus the
        # thread to end.
        #
        os.write(self.__signalwfd, "STOP")

        # Wait for tread to finish
        #
        self._t.join()
        self._t = None

        # Close communication channels
        #
        os.close(self.__signalrfd)
        os.close(self.__signalwfd)

        self.__signalrfd, self.__signalwfd = None, None

    def _processevents(self):
        """Process events from the sequence generated by the controller
        
            The sequence of events is generated by self._eventsequence()
        """
        for event in self._eventsequence():
            for callback in self._callbacks:
                callback(event)
        
    def _eventsequence(self):
        """Generate a sequence of xbox events
        
            This sequence ends when something is red from self._signalrfd
            
        Yields:
            Event: event generated by xbox controller
            
        """
        from select import select
        while True:
            r, w, x = select([self._xbox.fd,self.__signalrfd], [],[])
            if self.__signalrfd in r:
                break
            else:
                for event in self._xbox.read():
                    yield event


class XBoxStateController(object):
    """Record the state of an absolute axis of an XBox controller

    Event handler for xbox.XCEvents() that records the value of
    an absolute axis.

    Args:
        xcevents (xbox.XCEvents): Event sequence
        event (string or int): Name or code of an absolute axis
    """
    def __init__(self, xcevents, event='ABS_RX'):
        if type(event)==str:
            import evdev.ecodes
            self._eventcode = evdev.ecodes.ecodes[event]
        else:
            self._eventcode = event

        self._typecode = evdev.ecodes.ecodes['EV_ABS']

        self._value = 0.0

        absinfo = xcevents.absinfo(self._eventcode)
        self._min = float(absinfo.min)
        self._max = float(absinfo.max)

        xcevents.add_callback(self._callback)
        self._device = xcevents._xbox

    def __get_min(self):
        return self._min

    min = property(__get_min)
    """Minimal value the observed axis can take on
    """

    def __get_max(self):
        return self._max

    max = property(__get_max)
    """Maximal value the observed axis can take on
    """

    def __get_value(self):
        return self._value

    value = property(__get_value)
    """Current value of the observed axis
    """

    def __get_pvalue(self):
        if self._value>0:
            return self._value / self._max
        else:
            return -(self._value / self._min)

    pvalue = property(__get_pvalue)
    """Current value of the observed axis normalized to [-1,1]
    """

    def _get_driver_name(self):
        return self._device.name

    Driver_Name = property(_get_driver_name)

    def _callback(self, event):
        """Callback for XCEvents()

        Args:
            event (InputEvent): Event from a controller

        Returns:
            boolean: True if the event was handled. False otherwise
        """
        if event.type!=self._typecode or event.code!=self._eventcode:
            return False

        self._value = float(event.value)
        return True

    def getreadproperties(self):
        return ['pvalue']